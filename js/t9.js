// Generated by CoffeeScript 1.3.3
/*
Gets all possible words for a given number sequence typed on a standard
telephone 10-digit keypad. Gets ALL letter combinations and not just
those which are actual words (which would require a separate dictionary
lookup).

Characters that do not correspond with a letter will be ignored.

@param int|string numberSequence

@return array An array of unique lowercase string word possibilities
given the number sequence.
*/

var getPossibleWords, getTrieCombinations;

getPossibleWords = function(numberSequence) {
  var curLeaf, leaf, leaves, letter, letterTrie, letters, lfi, lfl, lti, ltl, newLeaves, nsi, nsl, num, numLetters, _i, _j, _k;
  numLetters = {
    0: null,
    1: null,
    2: "abc",
    3: "def",
    4: "ghi",
    5: "jkl",
    6: "mno",
    7: "pqrs",
    8: "tuv",
    9: "wxyz"
  };
  num = void 0;
  letter = void 0;
  letterTrie = {};
  leaves = [letterTrie];
  newLeaves = [];
  leaf = void 0;
  curLeaf = void 0;
  letters = void 0;
  if (!numberSequence) {
    return [];
  }
  numberSequence = numberSequence.toString();
  nsi = 0;
  nsl = numberSequence.length;
  for (nsi = _i = nsi; nsi <= nsl ? _i < nsl : _i > nsl; nsi = nsi <= nsl ? ++_i : --_i) {
    num = numberSequence[nsi];
    letters = (numLetters[num] ? numLetters[num].split("") : []);
    lti = 0;
    ltl = letters.length;
    for (lti = _j = lti; lti <= ltl ? _j < ltl : _j > ltl; lti = lti <= ltl ? ++_j : --_j) {
      letter = letters[lti];
      lfi = 0;
      lfl = leaves.length;
      for (lfi = _k = lfi; lfi <= lfl ? _k < lfl : _k > lfl; lfi = lfi <= lfl ? ++_k : --_k) {
        leaf = leaves[lfi];
        curLeaf = {};
        leaf[letter] = curLeaf;
        newLeaves.push(curLeaf);
        leaf["sequence"] = numberSequence.slice(nsi);
        lfi++;
      }
      lti++;
    }
    if (letters.length) {
      leaves = newLeaves;
      newLeaves = [];
    }
    nsi++;
  }
  return getTrieCombinations(letterTrie, {});
};

getTrieCombinations = function(trie, memo) {
  var answer, i, k, keys, kl, sci, scl, subans, subcomb, _i, _j;
  keys = Object.keys(trie);
  kl = keys.length;
  k = void 0;
  subcomb = void 0;
  scl = void 0;
  subans = void 0;
  answer = memo[trie["sequence"]];
  if (answer) {
    return answer;
  }
  answer = [];
  if (!kl) {
    return [];
  }
  i = 0;
  for (i = _i = i; i <= kl ? _i < kl : _i > kl; i = i <= kl ? ++_i : --_i) {
    k = keys[i];
    if (k === "sequence") {
      continue;
    }
    subcomb = getTrieCombinations(trie[k], memo);
    scl = subcomb.length;
    if (scl) {
      subans = [];
      sci = 0;
      for (sci = _j = sci; sci <= scl ? _j < scl : _j > scl; sci = sci <= scl ? ++_j : --_j) {
        subans.push(k + subcomb[sci]);
        sci++;
      }
      answer = answer.concat(subans);
    } else {
      answer.push(k);
    }
    i++;
  }
  memo[trie["sequence"]] = answer;
  return answer;
};
